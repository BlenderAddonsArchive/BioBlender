# Blender modules
import bpy
from bpy import *
import bpy.path
from bpy.path import abspath
import mathutils
from mathutils import *

# Python standard modules
from urllib.parse import urlencode
from urllib.request import *
from html.parser import *
from smtplib import *
from email.mime.text import MIMEText
import time
import platform
import os
import codecs
import base64
from math import *
import pickle
import shutil
import subprocess
import sys
import traceback
import copy


# A way to avoid infamous RestricContext error on boot
# ---(2015-MAY) correction, needing this means we are doing it wrong.
bootstrap = -1

# Generic BB2 "Global" variables
curFrame = 1
filePath = ""
activeTag = ""              # the active/selected model
projectLastFrame = 1        # Used in multi-pdb context to calculate offset Frame for GE Simulation


# PDB-MODELS-related variables (no chains-related variables)
pdbID = 0
pdbIDmodelsDictionary = {}  # Key: pdb_ID;  value: a dictionary containing all the models of the current (ID) PDB


# CHAINS-related variables
chainCount = 0          # PDB import preview: chains number in PDB
importChainID = []      # PDB import preview: chains names in PDB
importChainOrderList = []   # PDB import preview: chains to be imported
mainChainCacheDict = {}        # a cache to that contains only mainchain atoms for the various PDBid (key)
mainChainCache_NucleicDict = {}
mainChainCache_Nucleic_FilteredDict = {}
chainCacheDict = {}            # a cache to that contains all non-H atoms for the various PDBid (key)
chainCache_NucleicDict = {}
ChainModels = {}            # cache to contain model of chains and atoms belonging to chains


# EP-related variables
epOBJ = []                # holds a list of object generated by the EP visualization
curveCount = 0            # a counter for EP curves
dxData = []                # list[n] of Potential data
dimension = []            # list[3] of dx grid dimension
origin = []                # list[3] of dx grid origin
dxCache = {}                # cache to speed up vertexColor mapping
maxCurveSet = 4


# ==================================================================================================================

# Define common atom name as variables to avoid RSI from typing quotes


dic_lipo_materials = {}


def bootstrapping():
    print("Bootstrapping")
    # Gravity, rendering engine
    bpy.context.scene.render.engine = 'BLENDER_GAME'
    bpy.context.scene.game_settings.physics_gravity = 0.0
    bpy.context.scene.render.engine = 'BLENDER_RENDER'
    # Materials
    elencoMateriali = [CA, H, N, O, S, ZN, P, FE, MG, MN, CU, NA, K, CL, F]
    if not("C" in bpy.data.materials):
        bpy.ops.material.new()
        bpy.data.materials[-1].name = "C"
        bpy.data.materials["C"].diffuse_color = color[C]
    for m in elencoMateriali:
        if not(m in bpy.data.materials):
            bpy.data.materials['C'].copy()
            bpy.data.materials['C.001'].name = m
            bpy.data.materials[m].diffuse_color = color[m]
    create_fi_materials()

    # get next PDB ID
    global pdbID
    pdbID = getNewPDBid()
    # EmptySet (Hemi, BBCamera)
    bpy.context.scene.layers[19] = True
    for i in range(0, 19):
        bpy.context.scene.layers[i] = False
    bpy.context.scene.layers[19] = True
    elementiDaImportare = ['Empty', 'Hemi']
    try:
        for objName in elementiDaImportare:
            Directory = homePath + "data" + os.sep + "EmptySet.blend" + "/" + "Object" + "/"
            Path = os.sep + os.sep + "data" + os.sep + "EmptySet.blend" + "/" + "Object" + "/" + objName
            file_append(Path, objName, Directory)
    except Exception as E:
        raise Exception("Problem in import EmptySet.blend: ", E)
    global bootstrap
    bootstrap = 2


def getNewPDBid():
    print("get_new_PDB_id")
    tmp = 0
    for o in bpy.data.objects:
        if(o.bb2_pdbID != ""):
            tmp = o.bb2_pdbID
    tmp = tmp + 1
    return tmp


def create_fi_materials():
    print("create_fi_materials")
    global dic_lipo_materials
    try:
        for item in molecules_structure:
            for item_at in molecules_structure[item]:
                value_fi_returned = parse_fi_values(item, item_at)
                if not (value_fi_returned in dic_lipo_materials):
                    bpy.data.materials['C'].copy()
                    valuecolor = value_fi_returned
                    bpy.data.materials['C.001'].name = "matlipo_" + str(valuecolor)

                    v = float(valuecolor)
                    bpy.data.materials["matlipo_" + str(valuecolor)].diffuse_color = [v, v, v]
                    dic_lipo_materials[str(valuecolor)] = "matlipo_" + str(valuecolor)
    except Exception as E:
        raise Exception("Unable to create lipo materials", E)


def parse_fi_values(am_name, at_name):
    try:
        value_of_atom = values_fi[am_name][at_name]
        if float(value_of_atom) <= 0:
            value_final = (float(value_of_atom) + 2) / 4
        else:
            value_final = (float(value_of_atom) + 1) / 2
        value_final = "%5.3f" % float(value_final)
        return value_final
    except Exception as E:
        raise Exception("Unable to parse fi values", E)


def retrieve_fi_materials(am_name, at_name):
    material_value = parse_fi_values(am_name, at_name)
    material_name = dic_lipo_materials[material_value]
    return material_name



